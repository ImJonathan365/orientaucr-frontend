// CONTROLADOR MEJORADO CON ESTRATEGIA DE ACTUALIZACIÓN

@Controller
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private IUserService service;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private EmailService emailService;

    @Autowired
    private IEmailTemplateService emailTemplateService;

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody User loginUser) {
        try {
            if (loginUser.getUserEmail() == null || loginUser.getUserEmail().isBlank()) {
                return ResponseEntity.badRequest().body("El correo es obligatorio.");
            }
            if (loginUser.getUserPassword() == null || loginUser.getUserPassword().isBlank()) {
                return ResponseEntity.badRequest().body("La contraseña es obligatoria.");
            }
            
            // Verificar que el usuario esté verificado antes de permitir login
            Optional<User> userOpt = service.findByEmail(loginUser.getUserEmail());
            if (userOpt.isPresent() && !userOpt.get().isIsEmailVerified()) {
                return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("Debes verificar tu correo electrónico antes de iniciar sesión.");
            }
            
            User user = service.authenticateUser(loginUser.getUserEmail(), loginUser.getUserPassword());
            if (user != null) {
                List<String> permissions = user.getUserRoles().stream()
                        .flatMap(role -> role.getPermissions().stream())
                        .map(permission -> permission.getPermissionName())
                        .collect(Collectors.toList());
                String token = jwtUtil.generateToken(user.getUserEmail(), permissions);
                String refreshToken = jwtUtil.generateRefreshToken(user.getUserEmail(), permissions);
                user.setJwtToken(token);
                service.updateUserToken(user.getUserId(), token);
                return ResponseEntity.ok(Map.of("token", token, "refreshToken", refreshToken));
            } else {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Credenciales incorrectas.");
            }
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Error al autenticar el usuario: " + e.getMessage());
        }
    }

    @PostMapping("/register")
    public ResponseEntity<?> register(@RequestBody User user) {
        try {
            if (user.getUserName() == null || user.getUserName().isBlank()
                    || user.getUserEmail() == null || user.getUserEmail().isBlank()
                    || user.getUserPassword() == null || user.getUserPassword().isBlank()) {
                return ResponseEntity.badRequest().body("Nombre, correo y contraseña son obligatorios.");
            }
            
            Optional<User> existingUserOpt = service.findByEmail(user.getUserEmail());
            User targetUser;
            
            if (existingUserOpt.isPresent()) {
                User existingUser = existingUserOpt.get();
                
                if (existingUser.isIsEmailVerified()) {
                    // Usuario ya existe y está verificado
                    return ResponseEntity.badRequest().body("El correo ya está registrado y verificado.");
                } else {
                    // Usuario existe pero NO está verificado - actualizar datos
                    existingUser.setUserName(user.getUserName());
                    existingUser.setUserPassword(user.getUserPassword()); // Se encriptará en el service
                    existingUser.setUserLastname(user.getUserLastname());
                    existingUser.setUserProfilePicture(user.getUserProfilePicture());
                    // Mantener isEmailVerified = false
                    
                    service.update(existingUser);
                    targetUser = existingUser;
                }
            } else {
                // Usuario nuevo - crear
                user.setUserLastname(null);
                user.setUserProfilePicture(null);
                user.setIsEmailVerified(false);
                service.add(user);
                targetUser = service.findByEmail(user.getUserEmail())
                        .orElseThrow(() -> new IllegalStateException("Usuario no encontrado después de registrarse"));
            }

            // Generar token de verificación (independientemente si es nuevo o actualizado)
            String verificationToken = jwtUtil.generateToken(targetUser.getUserEmail(), List.of("VERIFY_EMAIL"), 24 * 60 * 60 * 1000);
            service.updateUserToken(targetUser.getUserId(), verificationToken);

            // Enviar correo de verificación
            EmailTemplate template = emailTemplateService.findByTemplateName("VERIFICAR CORREO");
            if (template == null || !template.isIsActive()) {
                throw new IllegalStateException("Plantilla de verificación no encontrada o inactiva");
            }

            String verificationUrl = "http://localhost:3000/verify-email?token=" + verificationToken;
            String emailBody = template.getTemplateBody()
                    .replace("{name}", targetUser.getUserName())
                    .replace("{verificationUrl}", verificationUrl);

            List<File> attachments = template.getAttachments().stream()
                    .map(attachment -> new File(attachment.getFilePath()))
                    .filter(File::exists)
                    .collect(Collectors.toList());

            emailService.sendEmailWithAttachment(targetUser.getUserEmail(), template.getTemplateSubject(), emailBody, attachments);
            
            String responseMessage = existingUserOpt.isPresent() 
                ? "Datos actualizados. Te hemos enviado un nuevo correo de verificación."
                : "Usuario registrado. Por favor, verifica tu correo electrónico.";
                
            return ResponseEntity.ok(responseMessage);
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Error al registrar el usuario: " + e.getMessage());
        }
    }

    @GetMapping("/verify")
    public ResponseEntity<?> verifyEmail(@RequestParam("token") String token) {
        try {
            if (token == null || token.trim().isEmpty()) {
                return ResponseEntity.badRequest().body("Token de verificación requerido.");
            }
            if (!jwtUtil.validateToken(token)) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Token de verificación inválido o expirado.");
            }
            String userEmail = jwtUtil.extractUsername(token);
            User user = service.findByEmail(userEmail)
                    .orElseThrow(() -> new IllegalStateException("Usuario no encontrado."));
            if (user.isIsEmailVerified()) {
                // Usuario ya verificado - generar tokens de sesión
                List<String> permissions = user.getUserRoles().stream()
                        .flatMap(role -> role.getPermissions().stream())
                        .map(permission -> permission.getPermissionName())
                        .collect(Collectors.toList());
                String newToken = jwtUtil.generateToken(userEmail, permissions);
                String newRefreshToken = jwtUtil.generateRefreshToken(userEmail, permissions);
                service.updateUserToken(user.getUserId(), newToken);
                
                return ResponseEntity.ok(Map.of(
                        "message", "El correo ya está verificado.",
                        "token", newToken,
                        "refreshToken", newRefreshToken
                ));
            }
            
            // Verificar usuario
            service.verifyUserEmail(user.getUserId());

            List<String> permissions = user.getUserRoles().stream()
                    .flatMap(role -> role.getPermissions().stream())
                    .map(permission -> permission.getPermissionName())
                    .collect(Collectors.toList());
            String newToken = jwtUtil.generateToken(userEmail, permissions);
            String newRefreshToken = jwtUtil.generateRefreshToken(userEmail, permissions);
            service.updateUserToken(user.getUserId(), newToken);

            return ResponseEntity.ok(Map.of(
                    "message", "Correo verificado correctamente.",
                    "token", newToken,
                    "refreshToken", newRefreshToken
            ));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error al verificar el correo.");
        }
    }

    @PostMapping("/refresh")
    public ResponseEntity<?> refresh(@RequestBody Map<String, String> body) {
        String refreshToken = body.get("refreshToken");
        if (refreshToken == null || !jwtUtil.validateRefreshToken(refreshToken)) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Refresh token inválido.");
        }
        String userEmail = jwtUtil.extractUsername(refreshToken);
        User user = service.findByEmail(userEmail).orElse(null);
        if (user == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Usuario no encontrado.");
        }
        List<String> permissions = user.getUserRoles().stream()
                .flatMap(role -> role.getPermissions().stream())
                .map(permission -> permission.getPermissionName())
                .collect(Collectors.toList());
        String newToken = jwtUtil.generateToken(userEmail, permissions);
        String newRefreshToken = jwtUtil.generateRefreshToken(userEmail, permissions);
        service.updateUserToken(user.getUserId(), newToken);
        return ResponseEntity.ok(Map.of("token", newToken, "refreshToken", newRefreshToken));
    }

    // MÉTODO OPCIONAL: Reenviar correo de verificación
    @PostMapping("/resend-verification")
    public ResponseEntity<?> resendVerificationEmail(@RequestBody Map<String, String> body) {
        try {
            String email = body.get("email");
            if (email == null || email.isBlank()) {
                return ResponseEntity.badRequest().body("El correo es obligatorio.");
            }
            
            Optional<User> userOpt = service.findByEmail(email);
            if (userOpt.isEmpty()) {
                return ResponseEntity.badRequest().body("No existe una cuenta con este correo.");
            }
            
            User user = userOpt.get();
            if (user.isIsEmailVerified()) {
                return ResponseEntity.badRequest().body("El correo ya está verificado.");
            }
            
            // Generar nuevo token y enviar correo
            String verificationToken = jwtUtil.generateToken(user.getUserEmail(), List.of("VERIFY_EMAIL"), 24 * 60 * 60 * 1000);
            service.updateUserToken(user.getUserId(), verificationToken);
            
            EmailTemplate template = emailTemplateService.findByTemplateName("VERIFICAR CORREO");
            if (template == null || !template.isIsActive()) {
                throw new IllegalStateException("Plantilla de verificación no encontrada o inactiva");
            }
            
            String verificationUrl = "http://localhost:3000/verify-email?token=" + verificationToken;
            String emailBody = template.getTemplateBody()
                    .replace("{name}", user.getUserName())
                    .replace("{verificationUrl}", verificationUrl);
            
            List<File> attachments = template.getAttachments().stream()
                    .map(attachment -> new File(attachment.getFilePath()))
                    .filter(File::exists)
                    .collect(Collectors.toList());
            
            emailService.sendEmailWithAttachment(user.getUserEmail(), template.getTemplateSubject(), emailBody, attachments);
            
            return ResponseEntity.ok("Correo de verificación reenviado.");
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Error al reenviar el correo: " + e.getMessage());
        }
    }
}
