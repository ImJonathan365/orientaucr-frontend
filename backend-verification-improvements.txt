// MEJORAS PARA EL BACKEND - Verificación con limpieza automática

/*
OPCIÓN 1: Modificar el endpoint de verificación existente
*/

@GetMapping("/verify")
public ResponseEntity<?> verifyEmail(@RequestParam String token) {
    try {
        // Validar el token
        if (!jwtUtil.isTokenValid(token)) {
            // Si el token no es válido, eliminar el usuario no verificado
            deleteUnverifiedUserByToken(token);
            return ResponseEntity.badRequest().body("Token inválido o expirado. Usuario eliminado.");
        }

        String email = jwtUtil.extractUsername(token);
        Optional<User> userOpt = service.findByEmail(email);
        
        if (userOpt.isEmpty()) {
            return ResponseEntity.badRequest().body("Usuario no encontrado.");
        }

        User user = userOpt.get();
        
        // Si ya está verificado, no hacer nada
        if (user.getIsEmailVerified()) {
            String newToken = jwtUtil.generateToken(user.getUserEmail(), getUserRoles(user), 24 * 60 * 60 * 1000);
            return ResponseEntity.ok(new LoginResponse(newToken, "Usuario ya verificado."));
        }

        // Verificar el usuario
        user.setIsEmailVerified(true);
        user.setUserToken(null); // Limpiar token de verificación
        service.update(user);

        // Generar nuevo token de autenticación
        String authToken = jwtUtil.generateToken(user.getUserEmail(), getUserRoles(user), 24 * 60 * 60 * 1000);
        
        return ResponseEntity.ok(new LoginResponse(authToken, "Correo verificado exitosamente."));
        
    } catch (Exception e) {
        // En caso de cualquier error, intentar limpiar usuario no verificado
        try {
            deleteUnverifiedUserByToken(token);
        } catch (Exception cleanupEx) {
            // Log del error de limpieza, pero no fallar por esto
            System.err.println("Error al limpiar usuario: " + cleanupEx.getMessage());
        }
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Error al verificar el correo: " + e.getMessage());
    }
}

// Método auxiliar para eliminar usuarios no verificados
private void deleteUnverifiedUserByToken(String token) {
    try {
        String email = jwtUtil.extractUsername(token);
        Optional<User> userOpt = service.findByEmail(email);
        
        if (userOpt.isPresent()) {
            User user = userOpt.get();
            // Solo eliminar si NO está verificado
            if (!user.getIsEmailVerified()) {
                service.delete(user.getUserId());
                System.out.println("Usuario no verificado eliminado: " + email);
            }
        }
    } catch (Exception e) {
        System.err.println("Error al extraer usuario del token: " + e.getMessage());
    }
}

/*
OPCIÓN 2: Tarea programada para limpiar usuarios no verificados (RECOMENDADA)
*/

@Component
public class EmailVerificationCleanupTask {
    
    @Autowired
    private UserService userService;
    
    // Ejecutar cada hora
    @Scheduled(fixedRate = 3600000) // 1 hora en milisegundos
    public void cleanupUnverifiedUsers() {
        try {
            // Eliminar usuarios no verificados creados hace más de 24 horas
            LocalDateTime cutoffDate = LocalDateTime.now().minus(24, ChronoUnit.HOURS);
            List<User> unverifiedUsers = userService.findUnverifiedUsersOlderThan(cutoffDate);
            
            for (User user : unverifiedUsers) {
                userService.delete(user.getUserId());
                System.out.println("Usuario no verificado eliminado por expiración: " + user.getUserEmail());
            }
            
            if (!unverifiedUsers.isEmpty()) {
                System.out.println("Limpieza completada: " + unverifiedUsers.size() + " usuarios eliminados");
            }
            
        } catch (Exception e) {
            System.err.println("Error en limpieza automática: " + e.getMessage());
        }
    }
}

// Agregar en UserService:
public List<User> findUnverifiedUsersOlderThan(LocalDateTime cutoffDate) {
    return userRepository.findByIsEmailVerifiedFalseAndCreatedDateBefore(cutoffDate);
}

// Agregar en UserRepository:
List<User> findByIsEmailVerifiedFalseAndCreatedDateBefore(LocalDateTime cutoffDate);

/*
OPCIÓN 3: Sistema híbrido (MEJOR PRÁCTICA)
*/

// 1. Verificación inmediata con limpieza
@GetMapping("/verify")
public ResponseEntity<?> verifyEmail(@RequestParam String token) {
    try {
        if (!jwtUtil.isTokenValid(token)) {
            deleteUnverifiedUserByToken(token);
            return ResponseEntity.status(HttpStatus.GONE)
                    .body("Token expirado. Por favor, regístrate nuevamente.");
        }
        
        // ... resto de la lógica de verificación
        
    } catch (ExpiredJwtException e) {
        deleteUnverifiedUserByToken(token);
        return ResponseEntity.status(HttpStatus.GONE)
                .body("Token expirado. Usuario eliminado. Por favor, regístrate nuevamente.");
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Error al verificar el correo: " + e.getMessage());
    }
}

// 2. Limpieza programada como respaldo
// 3. En el frontend, manejar el estado 410 (GONE) específicamente

/*
CONFIGURACIÓN ADICIONAL RECOMENDADA:
*/

// En application.properties:
spring.task.scheduling.enabled=true

// Habilitar programación de tareas en la clase principal:
@SpringBootApplication
@EnableScheduling
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
